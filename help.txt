RastaConverter - Help
=====================
RastaConverter by Jakub 'Ilmenit' Debski

Overview
--------
RastaConverter converts modern images to 8-bit Atari (mode 15) using an optimizer that builds a raster/kernel program with mid-line color changes and sprites. It uses FreeImage and (for GUI builds) SDL2/SDL2_ttf.

Usage:
  RastaConverter.exe InputFile [options]

Display layout (GUI)
--------------------
- Left: Source image resized to Atari width
 - Center: Current output preview (see dual-frame mode below)
- Right: Destination (source remapped to the Atari palette)
If the palette-mapped (right) image looks wrong (e.g., too gray), try a different palette file (/pal) or remap the source using an external tool (e.g., Timanthes) to better fit the chosen Atari palette.

Hotkeys (GUI)
-------------
- S / D: Save current best solution (all outputs)
- ESC:   Exit (asks for confirmation)
- In dual-frame mode:
  - A: show Frame A
  - Z: show Frame B
  - B: show Blended A/B (default)
Tip: With the current algorithms, the longer you run, the better the results. Some images require >1,000,000 evaluations for top quality.

Basic usage
-----------
RastaConverter supports both “/” and “--” style options and key=value pairs.

Required:
  /i=FILE or --input FILE      Input image path (PNG/JPG/etc.)
  /o=OUT  or --output OUT      Output base name (defaults to output.png)

Common options
--------------
- Palette and distance:
  /pal=FILE or /palette=FILE   Atari palette file (default Palettes/laoo.act)
  /distance=euclid|yuv|ciede|cie94    Color distance for optimization (default yuv)
  /predistance=euclid|yuv|ciede|cie94 Preprocess distance (default ciede)

- Image adjustments:
  /brightness=-100..100   (default 0)
  /contrast=-100..100     (default 0)
  /gamma=0..8             (default 1.0)
  /filter=box|bicubic|bilinear|bspline|catmullrom|lanczos3 (rescale, default box)
  /h=HEIGHT               Target height (default auto, max 240)

- Dithering (preprocess):
  /dither=none|floyd|rfloyd|line|line2|chess|2d|jarvis|simple|knoll (default none)
  /dither_val=FLOAT       Dither strength (default 1.0)
  /dither_rand=FLOAT      Randomness 0..1 (default 0)
  /details=FILE           Optional details map
  /details_val=FLOAT      Details strength (default 0.5)

-- Optimizer:
  /optimizer=dlas|lahc  Select optimizer (default dlas)
    Internals: both optimizers now use a shared optimization runner and evaluator.
    Acceptance is pluggable via policies (DLAS/LAHC). LAHC supports dual mode.
  /threads=N              Number of threads (default 1)
  /max_evals=ULL         Stop after N evaluations (default very large)
  /s=N                   DLAS/LAHC history length (default 1)
  /mutation_strategy=global|regional  (default global)
  /cache=MB              Line cache size in MB (default 16)
  /seed=random|NUMBER    Initial RNG seed (default random)
  /save=auto|N           Auto-save period: auto=time-based, or every N evals
  /onoff=FILE            Enable/disable registers per line from file
  /init=random|empty|less|smart  Initial program (default random)
     - random: broad exploration, stable default
     - empty: minimalist start
     - less: fewer colors initially; often yields quick gains but can plateau
     - smart: heuristic guided start
  /preprocess            Only run preprocessing; save -src.png and -dst.png and exit
  /quiet or /q           Reduce console output

Dual-frame mode (CRT blending)
--------------------------------------
Alternates two frames A/B each refresh; the eye perceives the average, increasing effective colors. Flicker arises from per-pixel A/B luminance differences, so the optimizer applies soft penalties.

Enable:
  /dual[=on|off]         Enable dual-frame mode (default off). Bare /dual enables it.
  /dual_init=dup|random|anti   Initial relation of frames (default dup)
    - dup:   B starts as a copy of A
    - random:B is A with random mutations applied
    - anti:  Like random, but pushes B further from A initially

Flicker control:
  /flicker_luma=0..1     How much luma flicker you accept (0=no, 1=full) (default 1)
  /flicker_chroma=0..1   How much chroma flicker you accept (0=no, 1=full) (default 1)
  WHY: Perceived flicker from luma is stronger than from chroma, so they are separate. Defaults accept full flicker; lower these if flicker is too visible.

Search behavior:
  By default, the optimizer uses staged scheduling between frames. Initialization duplicates A to B.
  /dual_mutate_ratio=0.5                (default 0.5; chance to mutate B vs A)
  /dual_strategy=alternate|staged       (default staged)
    - alternate: choose A/B each step using /dual_mutate_ratio
    - staged: focus a block of iterations on one frame, then switch
      /dual_stage_evals=N               (default 100000 per block)
      /dual_stage_start=A|B             (default A)
  /dual_cross_share_prob=F              (optional; default 0.05)
     Occasionally copy/swap a line between A and B to share structure.
     WHY: Balances effort between A and B; 0.5 mutates both equally often.

GUI behavior in dual-frame mode:
- Center preview defaults to Blended A/B; toggle with A/Z/B. The current mode is shown under the preview.

Outputs
-------
Single-frame mode:
- OUT.rp          Raster program
- OUT.mic         Screen data
- OUT.pmg         Player/missile data
- OUT.png         Saved preview
- OUT.csv         Statistics
- OUT.lahc        Optimizer state

Dual-frame mode adds:
- OUT-A.rp, OUT-A.mic, OUT-A.pmg   (Frame A)
- OUT-B.rp, OUT-B.mic, OUT-B.pmg   (Frame B)
- OUT-blended.png                  Blended preview
- OUT-flicker.png                  Flicker heatmap (luma delta)
- OUT-dual.csv, OUT-dual.lahc
To build an Atari executable, copy the generated outputs to the Generator directory and run build.bat there.

Notes
-----
- Dual mode is ~2–2.5× more expensive per evaluation (A and B are rendered each step).
- Internal pair evaluation uses a YUV fast path.

Debug logging (build-time)
--------------------------
At runtime, console logs are minimal. For verbose logging, configure CMake with:
-DTHREAD_DEBUG=ON  (optimization/executor logs)
-DUI_DEBUG=ON      (SDL UI event logs)
See BUILD.md: “Optional debug logging categories”.

Examples
--------
  RastaConverter.exe c64.png /threads=8 /optimizer=dlas /s=5
  RastaConverter.exe c64.png /optimizer=lahc /s=1000 /save=100000 /o=output_lahc.png

Why these options (and how to choose)
-------------------------------------
Palette (/pal):
- Why: Atari palette variants differ (emulators, monitors, calibration). A better-matching palette reduces distance and produces fewer artifacts.
- Choose: Start with laoo.act (balanced). If the destination (right panel) looks dull/gray, try other palettes (e.g., Real.act) or remap your source externally.

Distance functions (/distance, /predistance):
- Why: Euclidean RGB is fast but not perceptual; YUV weights luminance; CIE* distances match human perception but are slow.
- Choose: Default /distance=yuv balances quality/speed. Use /distance=ciede for the highest-fidelity runs if time permits. For preprocessing (/predistance), CIEDE helps make a better initial destination target but can slow dithering like /dither=knoll (switch to /predistance=yuv for speed).

Dithering (/dither, /dither_val, /dither_rand):
- Why: Preprocessing can add benign noise to reduce banding and steer optimization.
- Choose: Start with none. If your input has large smooth areas or banding, try floyd or chess. knoll yields pattern-like dither (slow with CIEDE preprocess). Use /dither_val≈1.0, increase to 2.0 if too gray; /dither_rand≈0.3–0.5 to reduce visible patterns.

Details map (/details, /details_val):
- Why: Emphasizes important regions (faces, eyes) by inflating their distance in preprocess; the optimizer then respects these areas more.
- Choose: Provide a grayscale mask; increase /details_val up to ~1.0 for stronger emphasis.

Initialization (/init):
- Why: Search space is huge; initial conditions bias early progress.
- Choose: random is stable default. empty is minimal (can be slow to get started). less gives quick first gains but can plateau; smart uses heuristics to align to the target structure.

Optimizer (/optimizer, /s):
- Why: DLAS generally moves fast early; LAHC can sometimes improve more in long plateaus.
- Choose: Keep /optimizer=dlas for most runs. Try LAHC on marathon runs. /s controls history; 3..10 are reasonable for DLAS.

Cache and threads (/cache, /threads):
- Why: Line caches reduce recomputation; memory and CPU scale with image height.
- Choose: /cache=16 is a good starting point per thread; increase if you observe frequent cache clears. Set /threads to the number of physical cores (or 1–2 less) to keep system responsive.

Dual-frame mode: deeper dive
--------------------------------------
Why dual mode (/dual=on):
- Alternating A/B frames produces a perceived average on CRTs, effectively increasing available colors beyond the 128 palette entries.
- Flicker comes mainly from luminance differences (Y) between A and B. Human vision tolerates chroma differences better.

Blend/distance:
- YUV is used internally for blending and distance for performance and perceptual alignment.

  Flicker control:
  - Use /flicker_luma and /flicker_chroma (0..1 acceptance). Higher means you tolerate more flicker.
  - Internally, flicker uses soft hinge penalties max(0, Δ−T)^p with fixed thresholds and exponents.

Mutation scheduling (/dual_strategy):
- alternate: choose which frame to mutate each step using /dual_mutate_ratio (e.g., 0.5 for balanced A/B).
- staged: focus many iterations on one frame, then switch (configure with /dual_stage_evals, /dual_stage_start). This can reduce horizontal banding by letting one frame settle before compensating with the other.

Initialization of B (/dual_init):
- dup: B starts as a copy of A (stable baseline).
- random: B diverges slightly from A via random mutations.
- anti: stronger initial divergence than random.

Performance tips
----------------
- Height matters: runtime scales with total pixels (160×H). Use smaller H when experimenting; scale up for final runs.
- Preprocess CIEDE is slow with /dither=knoll. Switch to /predistance=yuv if needed.
- Dual mode roughly doubles evaluation cost. Use fewer threads or smaller height if constrained.
- If cache clear logs appear, increase /cache or allow more time between clears.

Troubleshooting
---------------
- Flicker too visible: Lower /flicker_luma (accept less luma flicker) and/or lower /flicker_chroma. Inspect OUT-flicker.png to locate problem areas.
- Colors look washed out: Try another palette (/pal) or use /distance=ciede (slower). Increase /dither_val ≈ 1.5–2.0.
- Progress stalls early: Try a different /init (smart or less), or switch optimizer to LAHC for a long run.
- UI prints too many logs: make sure you did not enable UI_DEBUG/THREAD_DEBUG in your CMake options; otherwise rebuild without these flags.

Handy presets
-------------
- Fast preview (single-frame):
  /threads=4 /distance=yuv /init=random /save=auto

- High quality (single-frame):
  /threads=8 /distance=ciede /init=smart /s=7 /save=auto

- Dual staged (recommended):
  /dual=on /dual_strategy=staged /dual_stage_evalus=100000 --flicker_luma=1 --flicker_chroma=1

- Dual flicker-minimized:
  /dual=on /dual_strategy=staged /dual_stage_evalus=100000 /flicker_luma=0.2 /flicker_chroma=0.4

