RastaConverter - Help
=====================
RastaConverter by Jakub 'Ilmenit' Debski

Overview
--------
RastaConverter converts modern images to 8-bit Atari (mode 15) using an optimizer that builds a raster/kernel program with mid-line color changes and sprites. It uses FreeImage and (for GUI builds) SDL2/SDL2_ttf.
Usage:
  RastaConverter.exe InputFile [options]

Display layout (GUI)
--------------------
- Left: Source image resized to Atari width
 - Center: Current output preview (see dual-frame mode below)
- Right: Destination (source remapped to the Atari palette)
If the palette-mapped (right) image looks wrong (e.g., too gray), try a different palette file (/pal) or remap the source using an external tool (e.g., Timanthes) to better fit the chosen Atari palette.

Hotkeys (GUI)
-------------
- S / D: Save current best solution (all outputs)
- ESC:   Exit (asks for confirmation)
- In dual-frame mode:
  - A: show Frame A
  - Z: show Frame B
  - B: show Blended A/B (default)
Tip: With the current algorithms, the longer you run, the better the results. Some images require >1,000,000 evaluations for top quality.

Basic usage
-----------
RastaConverter supports both “/” and “--” style options and key=value pairs.

Required:
  /i=FILE or --input FILE      Input image path (PNG/JPG/etc.)
  /o=OUT  or --output OUT      Output base name (defaults to output.png)

Common options
--------------
- Palette and distance:
  /pal=FILE or /palette=FILE   Atari palette file (default Palettes/laoo.act)
  /distance=euclid|yuv|ciede|cie94    Color distance for optimization (default yuv)
  /predistance=euclid|yuv|ciede|cie94 Preprocess distance (default ciede)

- Image adjustments:
  /brightness=-100..100   (default 0)
  /contrast=-100..100     (default 0)
  /gamma=0..8             (default 1.0)
  /filter=box|bicubic|bilinear|bspline|catmullrom|lanczos3 (rescale, default box)
  /h=HEIGHT               Target height (default auto, max 240)

- Dithering (preprocess):
  /dither=none|floyd|rfloyd|line|line2|chess|2d|jarvis|simple|knoll (default none)
  /dither_val=FLOAT       Dither strength (default 1.0)
  /dither_rand=FLOAT      Randomness 0..1 (default 0)
  /details=FILE           Optional details map
  /details_val=FLOAT      Details strength (default 0.5)

- Optimizer:
  /optimizer=dlashc|lahc  Select optimizer (default dlashc)
  /threads=N              Number of threads (default 1)
  /max_evals=ULL         Stop after N evaluations (default very large)
  /s=N                   DLAS/LAHC history length (default 1)
  /mutation_strategy=global|regional  (default global)
  /cache=MB              Line cache size in MB (default 16)
  /seed=random|NUMBER    Initial RNG seed (default random)
  /save=auto|N           Auto-save period: auto=time-based, or every N evals
  /onoff=FILE            Enable/disable registers per line from file
  /init=random|empty|less|smart  Initial program (default random)
     - random: broad exploration, stable default
     - empty: minimalist start
     - less: fewer colors initially; often yields quick gains but can plateau
     - smart: heuristic guided start
  /preprocess            Only run preprocessing; save -src.png and -dst.png and exit
  /quiet or /q           Reduce console output

Dual-frame mode (CRT blending)
--------------------------------------
Alternates two frames A/B each refresh; the eye perceives the average, increasing effective colors. Flicker arises from per-pixel A/B luminance differences, so the optimizer applies soft penalties.

Enable:
  /dual[=on|off]         Enable dual-frame mode (default off). Bare /dual enables it.

Flicker control (soft hinge penalties):
  /flicker_luma_weight=WL      (default 1.0)
  /flicker_luma_thresh=TL      (default 3)
  /flicker_exp_luma=PL         (default 2)
  /flicker_chroma_weight=WC    (default 0.2)
  /flicker_chroma_thresh=TC    (default 8)
  /flicker_exp_chroma=PC       (default 2)
  WHAT: Penalize A↔B differences to reduce flicker, stronger for luminance (Y) than for chroma (U/V).
  WHY: Human vision is more sensitive to flicker from brightness than from color.
  HOW: For each pixel, penalties grow smoothly once difference exceeds the threshold TL/TC; exponents (PL/PC) control slope (2=quadratic is smooth and stable).
  UNITS: Y is on roughly 0..255 scale; U/V magnitudes are smaller (scales derived from the YUV transform used in code).

Search behavior:
  The optimizer alternates updates between frames A and B. Initialization duplicates A to B.
  /dual_mutate_ratio=0.5                (default 0.5; chance to mutate B vs A)
     WHY: Balances effort between A and B; 0.5 mutates both equally often.

GUI behavior in dual-frame mode:
- Center preview defaults to Blended A/B; toggle with A/Z/B. The current mode is shown under the preview.

Outputs
-------
Single-frame mode:
- OUT.rp          Raster program
- OUT.mic         Screen data
- OUT.pmg         Player/missile data
- OUT.png         Saved preview
- OUT.csv         Statistics
- OUT.lahc        Optimizer state

Dual-frame mode adds:
- OUT-A.rp, OUT-A.mic, OUT-A.pmg   (Frame A)
- OUT-B.rp, OUT-B.mic, OUT-B.pmg   (Frame B)
- OUT-blended.png                  Blended preview
- OUT-flicker.png                  Flicker heatmap (luma delta)
- OUT-dual.csv, OUT-dual.lahc
To build an Atari executable, copy the generated outputs to the Generator directory and run build.bat there.

Notes
-----
- Dual mode is ~2–2.5× more expensive per evaluation (A and B are rendered each step).
- Internal pair evaluation uses a YUV fast path.

Debug logging (build-time)
--------------------------
At runtime, console logs are minimal. For verbose logging, configure CMake with:
-DTHREAD_DEBUG=ON  (optimization/executor logs)
-DUI_DEBUG=ON      (SDL UI event logs)
See BUILD.md: “Optional debug logging categories”.

Examples
--------
  RastaConverter.exe c64.png /threads=8 /optimizer=dlashc /s=5
  RastaConverter.exe c64.png /optimizer=lahc /s=1000 /save=100000 /o=output_lahc.png

Why these options (and how to choose)
-------------------------------------
Palette (/pal):
- Why: Atari palette variants differ (emulators, monitors, calibration). A better-matching palette reduces distance and produces fewer artifacts.
- Choose: Start with laoo.act (balanced). If the destination (right panel) looks dull/gray, try other palettes (e.g., Real.act) or remap your source externally.

Distance functions (/distance, /predistance):
- Why: Euclidean RGB is fast but not perceptual; YUV weights luminance; CIE* distances match human perception but are slow.
- Choose: Default /distance=yuv balances quality/speed. Use /distance=ciede for the highest-fidelity runs if time permits. For preprocessing (/predistance), CIEDE helps make a better initial destination target but can slow dithering like /dither=knoll (switch to /predistance=yuv for speed).

Dithering (/dither, /dither_val, /dither_rand):
- Why: Preprocessing can add benign noise to reduce banding and steer optimization.
- Choose: Start with none. If your input has large smooth areas or banding, try floyd or chess. knoll yields pattern-like dither (slow with CIEDE preprocess). Use /dither_val≈1.0, increase to 2.0 if too gray; /dither_rand≈0.3–0.5 to reduce visible patterns.

Details map (/details, /details_val):
- Why: Emphasizes important regions (faces, eyes) by inflating their distance in preprocess; the optimizer then respects these areas more.
- Choose: Provide a grayscale mask; increase /details_val up to ~1.0 for stronger emphasis.

Initialization (/init):
- Why: Search space is huge; initial conditions bias early progress.
- Choose: random is stable default. empty is minimal (can be slow to get started). less gives quick first gains but can plateau; smart uses heuristics to align to the target structure.

Optimizer (/optimizer, /s):
- Why: DLAS generally moves fast early; LAHC can sometimes improve more in long plateaus.
- Choose: Keep /optimizer=dlashc for most runs. Try LAHC on marathon runs. /s controls history; 3..10 are reasonable for DLAS.

Cache and threads (/cache, /threads):
- Why: Line caches reduce recomputation; memory and CPU scale with image height.
- Choose: /cache=16 is a good starting point per thread; increase if you observe frequent cache clears. Set /threads to the number of physical cores (or 1–2 less) to keep system responsive.

Dual-frame mode: deeper dive
-------------------------------------
Why dual mode (/dual=on):
- Alternating A/B frames produces a perceived average on CRTs, effectively increasing available colors beyond the 128 palette entries.
- Flicker comes mainly from luminance differences (Y) between A and B. Human vision tolerates chroma differences better.

Blend/distance:
- YUV is used internally for blending and distance for performance and perceptual alignment.

Flicker penalties (/flicker_*):
- Why: Hard thresholds stall exploration. Hinge penalties (max(0, Δ−T)^p) keep the landscape smooth so “bad” regions can improve while still discouraging flicker.
- Choose: Start with WL=1.0, TL=3; WC=0.2, TC=8; exponents=2. Increase WL or lower TL to suppress flicker harder; increase TC or lower WC to allow more chroma variance. Consider relaxing penalties in very detailed regions (masked by motion and texture).

Mutation strategy (dual internal alternating updates, /dual_mutate_ratio):
- Why: Coordinated evolution prevents one frame from diverging too far from the other while still creating color diversity.
- Choose: alternate updates internally with /dual_mutate_ratio≈0.5 to balance A and B updates. B is initialized from A for stability.

Performance tips
----------------
- Height matters: runtime scales with total pixels (160×H). Use smaller H when experimenting; scale up for final runs.
- Preprocess CIEDE is slow with /dither=knoll. Switch to /predistance=yuv if needed.
- Dual mode roughly doubles evaluation cost. Use fewer threads or smaller height if constrained.
- If cache clear logs appear, increase /cache or allow more time between clears.

Troubleshooting
---------------
- Flicker too visible: Increase /flicker_luma_weight or decrease /flicker_luma_thresh; optionally increase /flicker_chroma_weight modestly. Inspect OUT-flicker.png to locate problem areas.
- Colors look washed out: Try another palette (/pal) or use /distance=ciede (slower). Increase /dither_val ≈ 1.5–2.0.
- Progress stalls early: Try a different /init (smart or less), or switch optimizer to LAHC for a long run.
- UI prints too many logs: make sure you did not enable UI_DEBUG/THREAD_DEBUG in your CMake options; otherwise rebuild without these flags.

Handy presets
-------------
- Fast preview (single-frame):
  /threads=4 /distance=yuv /init=random /save=auto

- High quality (single-frame):
  /threads=8 /distance=ciede /init=smart /s=7 /save=auto

- Dual balanced (dual-frame):
  /dual=on \
  /flicker_luma_weight=1.0 /flicker_luma_thresh=3 /flicker_chroma_weight=0.2 /flicker_chroma_thresh=8 \
  /dual_mutate_ratio=0.5

- Dual flicker-minimized:
  Same as above, but /flicker_luma_weight=1.3 /flicker_luma_thresh=2.5

